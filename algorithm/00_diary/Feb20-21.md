# 알고리즘 별 비교

## List

### 검색

**완전 검색 (Exaustive Search)**

- Brute Force
- 모든 경우의 수를 테스트 하고 해답 도출

**그리디 (Greedy Algorithm)**

- 여러 경우 중, 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행.

**셀렉션 알고리즘 (Selection Algorithm)**

- 저장되어 있는 자료로부터 k 번째로 큰 혹은 작은 원소를 찾는 방법
- 정렬 알고리즘을 이용하여 자료를 정렬하고, 원하는 순서에 있는 원소 가져온다.

**바이너리 서치 (Binary Search)**

- 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 정하고 검색을 계속

**순차 검색 ()**

- 

### 정렬

**버블 정렬 (Bubble Sort)**

- 인접한 두 개 원소를 비교하며 자리를 계속 교환해가는 방식
- `O(n^2)`

**카운팅 정렬 (Counting Sort)**

- 

**선택 정렬 (Selection Sort)**

- 주어진 자료 중, 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
- 최소값을 찾고 맨 앞과 교환
- 나머지로 반복

**퀵 정렬 (Quick Sort)**



**삽입 정렬 (Insertion Sort)**



**병합 정렬 (Merge Sort)**









## String

> 찾고자 하는 문자열 패턴의 길이 m , 총 문자열 길이 n

고지식한 패턴 검색 알고리즘  (Brute Force) `O(mn)`

- 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교.
- 1글자씩 비교하다가 실패하면 1칸 이동해서 다시 1글자 씩 비교

카프 - 라빈 알고리즘 `O(n)`

- 

KMP 알고리즘 `O(n)`

- 불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행
- 반복되는 문자열을 통해서 매칭이 실패했을 때 돌아갈 곳을 계산한다.

보이어 - 무어 알고리즘 `최악의 경우 O(mn), 입력에 다라 다르지만 일반적으로 O(n)보다 덜 든다.`

- 오른쪽에서 왼쪽으로 비교
- 대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘
- 오른쪽 끝 문자 불일치하고 문자가 패턴 내에 존재하지 않을 경우, 패턴의 길이만큼 이동한다.
- 오른쪽 끝 문자 불일치하고 문자가 패턴 내에 존재하는 경우, 패턴에서 일치하는 문자를 찾아서 이동한다.
- 



## 비트 연산자

숫자를 2진수로 표현했을 때, 각 자리 수를 가지고 비교하는 방식

`<<` : 비트열 왼쪽으로 2^n 배

`>>` : 비트열 오른쪽으로 2^n 나눈 만큼

`&` : 비트 단위 AND 연산

`|` : 비트 단위 OR 연산

`1<<n` : 2^n

i & (1<<j) : i의 j 번째 비트가 1인지 아닌지