# Feb 22

> Algorithm_Stack

### 공부 내용

#### Stack

물건을 쌓아 올리 듯 자료를 쌓아 올린 형태의 자료구조.

마지막에 삽입한 자료를 가장 먼저 꺼내는 후입선출 형태 (LIFO, Last In First Out)



#### 용어

top : 스택에서 마지막 삽입된 원소의 위치

push : 삽입. 저장소에 자료를 저장

```python
def push(item):
    s.append(item)
```

pop : 삭제. 저장소에서 자료를 꺼냄

```python
def pop():
    if len(s) == 0:
        # underflow
        return
    else:
        return s.pop(-1)
```

isEmpty : 스택이 공백인지 아닌지를 확인하는 연산

peek : 스택의 top에 있는 원소를 반환하는 연산



#### 스택의 응용 1. 괄호 검사

> 문자열에 있는 괄호를 차례로 조사하면서 왼쪽 괄호를 만나면 스택에 삽입, 오른쪽 괄호를 만나면 스택에서 top 괄호를 삭제한 후, 오른쪽 괄호와 짝이 맞는지를 검사한다.



소괄호만이 아닌, 대괄호, 중괄호도 껴서 새로 작성해보세요.



#### 스택의 응용 2. function call

> 프로그램에서 함수 호출과 복귀에 따른 수행 순서를 관리
>
> 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출 구조.
>
> 따라서 후입 선출 구조의 스택을 활용하여 수행 순서를 관리

```python
def func2():
    print('함수 2 시작')
    print('함수 2 종료')

def func1():
   	print('함수 1 시작')
    func2()
    print('함수 1 종료')

print('메인시작')
func1()
print('메인끝')
```

```python
# 실행 결과
메인시작
함수 1 시작
함수 2 시작
함수 2 종료
함수 1 종료
메인끝
```



#### 재귀호출

> 자기 자신을 호출하여 순환 수행되는 것

```python
def fibo(n):
    if n < 2:
        return n
   	else:
        return fibo(n-1) + fibo(n-2)
```

문제점 → 엄청난 중복 호출이 존재

해결법 → Memoization



#### Memoization

> 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술. 동적계획법의 핵심.

```python
# Memoization 을 활용한 피보나치

# memo를 위한 배열을 할당하고, 모두 0으로 초기화 한다.
# memo[0]을 0으로 memo[1]은 1로 초기화 한다.

def fibo1(n):
    global memo
    if n>=2 and len(memo) <= n:
        memo.append(fibo1(n-1) + fibo(n-2))
    return memo[n]

memo = [0, 1]
```



#### DP (Dynamic Programming)

> 최적화 문제를 해결하는 알고리즘.
>
> 입력크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 활용하여 큰 크기의 부분 문제들을 해결하여, 
>
> 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘

```python
def fibo2(n):
    f = [0, 1]
    
    for i in range(2, n+1):
        f.append(f[i-1] + f[i-2])
        
    return f[n]
```

recursive 방식 : ???

iterative 방식 : ???

memoization을 재귀적 구조에 사용하는 것 보다 반복적 구조로 DP를 구현한 것이 성능면에서 보다 효율적이다.

재귀적 구조는 내부에 시스템 호출 스택을 사용하는 오버헤드가 발생하기 때문.



#### DFS (깊이우선탐색)

> 비선형구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요.
>
> 두가지 방법으로 DFS (깊이우선탐색) / BFS (너비우선탐색) 이 있다.

시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해가다가

더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서

다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회 방법



시작 정점 v를 결정하여 방문

정점 v에 인접한 정점 중에서

​	방문하지 않은 정점 w가 있으면 정점 v를 스택에 push 하고 정점 w를 방문.

​	그리고 w를 v로 하여 다시 반복

​	방문하지 않은 정점이 없으면, 탐색의 방향을 바꾸기 위해서

​	스택을 pop하여 받은 가장 마지막 방문 정점을 v로 하여 다시 반복

스택이 공백이 될 때까지 반복



```python
visited[], stack[] 초기화
DFS(v)
	v 방문;
    visited[v] ← true;
    do {
        if (v의 인접 정점 중 방문 안한 w 찾기)
        	push(v);
        while(w){
            w 방문;
            visited[w] ← true;
            push(w);
            v ← w;
            v의 인접 정점 중 방문 안한 w 찾기
        }
        v ← pop(stack);
    } while(v)
end DFS()
```



### 느낀 점

시험 공부를 하느라 수업을 제대로 못들었다.

못들었다는 말을 최근에 너무 많이 쓰고 있는 것 같다.

그래도 어느 정도 이해는 되었으나, 내일 실습을 하면서 어느 정도일지 체크해봐야겠다.



### 해야할 것

- [ ] 
